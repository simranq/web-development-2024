# DAY 51 #
One more use -
in all our html (ejs files) we've that shared header tag same in every file with customized a link's href adjustments. it means that code needs a lot of adjustments.
now, ejs has a feature called 'includes' that helps us deal with that prblm.
It is an ejs file to split ur big html file into smaller, more manageable pieces.


WHAT DID WE DO ON DAY 51?

added includes folder in views folder
In 'includes' folder we created a 'header.ejs' file copy the header here.
<%- content %> =>   '-' is another ejs syntax we use when we wanna render some HTML content.
cuz, by default, if we o/p smthg in this ejs form, it o/ps as raw text i.e user can't inject html text (like imgs) thus top-notch security!!
<%= content %> => '=' sign escapes the value that it o/ps i.e. translates it into raw text. Useful for user-generated content and not for including some HTML code.
<%- %>         => '-' doesn't escape but will actually treat HTML code as HTML code instead of raw text.
<%- include %> =>  allows us to specify a path to another file & then that file would be parsed by ejs as well and it will generate that html content and inject nd treat it as html content. By default, u can use relative path.
can pass dynamic data too.

<%- include('includes/header', {}) %> => 'path', object with data in {}
                                      => just like render()

TO REDUCE CODE REDUNDANCY (OF HEADER & SIDE-DRAWER), WE'VE CREATED SEPARATE FILES WITHIN INCLUDES FOLDER  
<%- include('includes/header') %>
<%- include('includes/side-drawer') %>
BY WRITING THE ABOVE 2 LINES OF CODE, WE CAN REDUCE CODE REPETITION OF THE HEADER & ASIDE TAGS.
Code can be easily maintained.
we did the same thing with the <head> by => '<%- include('includes/head') %>'
Note that, restaurant-item.ejs has dynamic data but include accepts dynamic data too even though'-' is there. but add object {} too. here restaurant key
1 prblm is that ejs language isn't understood by VS Code, which can be done by installing 'EJS LANGUAGE SUPPORT'.

WE WERE ABLE TO CHANGE THE HTML CONTENT DYNAMICALLY ON THE SERVER USING EJS. WE NEEDED THIS TEMPLATE ENGINE ONLY CUZ WE HAD SOME DYNAMIC CONTENT!
& HENCE WE NEEDED A SERVER-SIDE LANGUAGE.
BENEFITS-
using include we can divide file into segments
ejs allows us to o/p values <%= gffffnh %> as raw text.
also run js lang too like 'for', 'if-else'
# NOTE   -    ALWAYS KNOW THAT SERVER GETS THE FINISHED  HTML CODE & NOT ALL THE EJS..
static css & js files can be served using express.static (static is a middleware) of a specific folder.
#-------------------------------------------------------------------------------------------------------------
# DAY 51    PART II
# TOPIC - Advanced server-side code    -   dynamic routes, error handling, patterns
# - BUILDING A MORE DYNAMIC & REALISTIC BACKEND

# dynamic routes
restaurants are dyn user gen data. thus each resto should have unique id so that we dont have to create routes for each resto. as it would be too hectic. here, comes the concept of dynamic routes

req.params.id -> params contains objects which then have any dynamic placeholder defined by us (here, id)
dr are crucial features.

TO CREATE UNIQUE IDs WE INSTALLED A 3RD PARTY PACKAGE => npm install uuid
uuid.v4() => v4 generates a random unique id i.e a string
  restaurant.id = uuid.v4(); => restaurant.id (creates 'id' key) gets created in restaurants.json

# custom middleware & err handling
after referring notes from app.js, created 404.ejs & 500.ejs whilst we were at it
304 - 
chrome is caching all these files locally on pc for quicker responses nd this can be undone simply by unchecking disable cache

       (earlier)            (now)
  res.render('404'); ->  res.status().render('404');
  res.status().render('404');->default status would be 200 and we can customize it by passing arguments in status.

# optimizing code
add a new subfolder 'util' where all the utilities(functions) are shared.
always "require('package');", else error would arise

first require built-in packages > 3rd party packages > own files
You can expose (or export) fxns and variables/constants.

module.exports = {
    getStoredRestaurants : getStoredRestaurants
};
You
module.exports = {
    getStoredRestaurants : getStoredRestaurants
};

Explanation
1. module.exports: This object is used to define what a module exports and makes available for other files to require.
2. getStoredRestaurants: getStoredRestaurants: This is exporting a function (or any other variable) named getStoredRestaurants.
The first getStoredRestaurants is the name you’re giving to the function in the exports object. It is upto me to name.
The second getStoredRestaurants is the actual function you’re exporting.


const filePath = path.join(__dirname, ".." ,"data", "restaurants.json");
from util => root => data => restaurants.json

#creating a new folder 'routes'